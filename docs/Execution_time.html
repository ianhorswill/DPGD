
<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	<!-- generic metadata -->
	<title>Execution time&#xA;</title>
	<meta name="author" content="Ian Horswill">
	<meta name="description" content="An introduction to declarative programming with applications to vidoegames">
	<meta name="generator" content="Booker">

	<!-- seo helpers: generic, twitter, facebook/opengraph -->
	<meta itemprop="name" content="Execution time&#xA;">
	<meta name="twitter:title" content="Execution time&#xA;">
	<meta property="og:title" content="Execution time&#xA;" />
	<meta property="og:type" content="article" />
	<meta property="og:site_name" content="Declarative Programming for Game Designers" />
	
	<!-- stylesheets -->
	<!-- bootstrap needs to come first -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">

	<!-- then our style sheet -->
	<link rel="stylesheet" href="site.css"> 

	<!-- sample fonts, please feel free to replace with your preferred ones -->
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat|Public+Sans:400,700&display=swap&subset=latin-ext"> 

	<!-- highlightjs is used for source code formatting inside <code> tags. feel free to remove it. -->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11/build/styles/atom-one-dark.min.css">
	<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11/build/highlight.min.js"></script>
	<script src="step.js"></script>
	<script src="NDScript.js"></script>
	<script>hljs.highlightAll();</script>
	
	<!-- use MathJax for latex rendering -->
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

	<!-- Use mermaid to render diagrams -->
	<script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'dark' });
    </script>
</head>

<body>
<div class="container-fluid shadow header">
	<div class="container">
		<div class="col-md-7 header-contents">
				<a class="backgroundlink" href="Part_I.html"> Part I
 </a>
&nbsp;&#x25BB;&nbsp;				<a class="backgroundlink" href="Clairvoyant_programming.html"> Clairvoyant programming
 </a>
&nbsp;&#x25BB;&nbsp;				<a class="backgroundlink" href="NDScript.html"> Clairvoyant algorithms
 </a>
&nbsp;&#x25BB;&nbsp;				<a class="backgroundlink" href="Pathfinding.html"> Finding paths
 </a>
			<h1><a id="linkToIndex" class="simplelink" href="index.html"> Execution time
</a></h1>
					<p>
					<span style="padding:.25rem; padding-left:.5rem; padding-right:.5rem; background-color:red; color:black;">
					   incomplete draft
					</span>
					</p>
		</div>
	</div>
</div>

	<!-- Make clicking On Step code pop up a step interpreter and copy the code into the clipboard -->
	<script>
	document.querySelector("body").addEventListener('click', function(e) {
		var element = e.target.closest('code');
		if(element !== null) {
			if (element.classList.contains('language-Step')) {
				var interp = window.open("https://ianhorswill.github.io/StepSandbox", "Step sandbox");
				var handler = function(e) { 
					interp.postMessage(element.textContent, "*");
					window.removeEventListener('message', handler);
				};
				window.addEventListener('message', handler);
			} else if (element.classList.contains('language-NDScript')) {
				var interp = window.open("https://ianhorswill.github.io/NDScriptSandbox", "NDScript sandbox");
				var handler = function(e) { 
					interp.postMessage(element.textContent, "*");
					window.removeEventListener('message', handler);
				};
				window.addEventListener('message', handler);
			}
		}
	}, false);
	</script>



<div class="container-fluid">
	<div class="row justify-content-center">
		<div class="col-md-7 index-contents">
			<div class="container shadow blog-contents">

<p>Now let's think about the execution time of this algorithm.  Again, the core loop is just:</p>
<pre><code class="language-ndscript">while (!done()) choose right(); or down();
</code></pre>
<p>Real clairvoyant machines don't exist.  But if they did, their execution time would just be the time it takes for them to run the chosen (successful) path.  For example, this path, shown in green:</p>
<pre class="mermaid">graph TB
style s fill:green
   style d fill:green
   style dr fill:green
   style drr fill:green
   style drrr fill:green
   
   s["(1,2)"] -- right -->  r["(2,2)"] -- right --> rr["(3,2) obstacle"]
   style rr fill:red
   r -- down --> rd["(2,3)"] -- right --> rdr["(3,3)"] -- right --> rdrr["(4,3)"] -- right --> rdrrr["(5,3) off map"]
   style rdrrr fill:red
   rdrr -- down --> rdrrd["(4,4)"]
   style rdrrd fill:gray
   rdr -- down --> rdrd["(3,4) obstacle"]
   style rdrd fill:red
   rd -- down --> rdd["(2,4)"] -- right --> rddr["(3,4) obstacle"]
   style rddr fill:red
   rdd -- down --> rddd["(2,5) off map"]
   style rddd fill:red
   s -- down --> d["(1,3)"] -- right --> dr["(2,3)"]
   dr["(2,3)"] -- right --> drr["(3,3)"] -- right --> drrr["(4,3)"] -- right --> drrrr["(5,3) off map"]
   style drrrr fill:red
   drrr -- down --> drrrd["(4,4)"]
   style drrrd fill:green
   drr -- down --> drrd["(3,4) obstacle"]
   style drrd fill:red
   dr -- down --> drd["(2,4)"] -- right --> drdr["(3,4) obstacle"]
   style drdr fill:red
   drd -- down --> drdd["(2,5) off map"]
   style drdd fill:red
   d -- down --> dd["(1,4)"] -- right --> ddr["(2,4)"] -- right --> ddrr["(3,4) obstacle"]
   style ddrr fill:red
   dd -- down --> ddd["(1,5) off map"]
   style ddd fill:red
   ddr -- down --> ddrd["(2,5) off map"]
   style ddrd fill:red
</pre>
<p>Each step in that path represents one choice point.  There's one choice point per iteration of the loop and each iteration takes a fixed amount of time (technically, <span class="math">\(O(1)\)</span> time<a id="fnref:1" href="#fn:1" class="footnote-ref"><sup>1</sup></a>).  So for this algorithm, execution time on a true clairvoyant machine would be proportional to the length of the chosen path.  For an <span class="math">\(n\times n\)</span> grid, that path has <span class="math">\(n-1\)</span> right motions and <span class="math">\(n-1\)</span> down motions, so a total of <span class="math">\(2n-2\)</span> iterations.  The cost is <span class="math">\(O(n)\)</span>, which is often paraphrased as &quot;roughly proportional to <span class="math">\(n\)</span>&quot;, although the true meaning is a little more complicated.<a id="fnref:2" href="#fn:2" class="footnote-ref"><sup>2</sup></a></p>
<p>That's for a truly clairvoyant machine.  For a real machine, we use some kind of a solver to run the algorithm.  We'll talk about that <a href="NDScript_execution.html">next</a>.  For the moment, we just need to know it uses some process of trial and error to find a path that works.</p>
<p>In the <strong>best case</strong>, the solver guesses a successful path on the first try and so it's more or less the same as the clairvoyant system.  But in the <strong>worst case</strong>, the solver has to try <strong>all nodes</strong> in the choice tree.  How many nodes is that?  For the graph above, which is only a partial graph of our 5x5 pathfinding problem, that's 27 nodes, rather than the 6 along the selected successful path.</p>
<h2 id="intractability">Intractability</h2>
<p>More generally, suppose we have an NDScript program that make a series of 2-way choices.  To keep the analysis simple, let's assume it never fails or succeeds until all the choices have been made.  Then the choice tree looks something like this:</p>
<pre class="mermaid">graph TB
s["choose"] -- A --> a["choose"] -- A --> aa["choose"] -- A --> aaa["choose"]-- A --> aaaa["fail"]
style aaaa fill:red
aaa -- B --> aaab["fail"]
style aaab fill:red
aa -- B --> aab["choose"] -- A --> aaba["fail"]
aab -- B --> aabb[fail]
style aaba fill:red
style aabb fill:red
a -- B --> ab[choose] -- A --> aba[choose] --> abaa[fail]
style abaa fill:red
aba -- B --> abab[fail]
style abab fill:red
ab -- B --> abb[choose] -- A --> abba[fail]
style abba fill:red
abb -- B --> abbb[fail]
style abbb fill:red

s -- B --> b["choose"] -- A --> ba["choose"] -- A --> baa["choose"]-- A --> baaa["fail"]
style baaa fill:red
baa -- B --> baab["fail"]
style baab fill:red
ba -- B --> bab["choose"] -- A --> baba["fail"]
bab -- B --> babb[fail]
style baba fill:red
style babb fill:red
b -- B --> bb[choose] -- A --> bba[choose] --> bbaa[success]
style bbaa fill:green
bba -- B --> bbab[fail]
style bbab fill:red
bb -- B --> bbb[choose] -- A --> bbba[fail]
style bbba fill:red
bbb -- B --> bbbb[fail]
style bbbb fill:red
</pre>
<p>The first level of the tree has one node, the second 2, the third 4, the next 8, etc.  Level <span class="math">\(i\)</span> has <span class="math">\(2^{i-1}\)</span> nodes.  And a tree with <span class="math">\(h\)</span> levels has <span class="math">\(2^h-1\)</span> nodes; the tree above, which has height 5, has 31 nodes.  So a solver that is lucky and finds the correct path right away, only explores 5 nodes.  But a solver that has to try every node has to look at 31.  The difference is more dramatic the levels in the tree.  For 10 choices, the lucky scenario looks at 10 nodes, but the worst-case scenario looks at 1023 nodes.</p>
<p>More generally, if a solver runs a program that makes a series on <span class="math">\(n\)</span> 2-way choices, then the <strong>best</strong> we can hope for is that it runs in <span class="math">\(O(n)\)</span> time.<a id="fnref:3" href="#fn:3" class="footnote-ref"><sup>3</sup></a>  That requires it to more or less always guess right.  But the <strong>worst case</strong>, where it has to explore the whole tree, will require at least <span class="math">\(O(2^n)\)</span> time.<a id="fnref:4" href="#fn:4" class="footnote-ref"><sup>4</sup></a>  That is to say, it's <strong>exponential time</strong>, which is horrific<a id="fnref:5" href="#fn:5" class="footnote-ref"><sup>5</sup></a>: each additional choice doubles the execution time.  If the choices are <span class="math">\(k\)</span>-way rather than 2-way, then it's <span class="math">\(O(k^n)\)</span> time, which is even worse.</p>
<p>Exponential algorithms don't scale well.  Problems that require exponential algorithms are said to be <a href="https://en.wikipedia.org/wiki/Computational_complexity_theory#Intractability">intractable</a>.  As far as we know, simulating clairvoyant algorithms requires exponential time in the general case.<a id="fnref:6" href="#fn:6" class="footnote-ref"><sup>6</sup></a></p>
<h2 id="real-world-applications">Real-world applications</h2>
<p>The good news is that a surprising number of problems of practical interest can be solved surprisingly quickly, even by relatively simple solvers.  Sometimes this is because choice tree is so full of solutions the solver can't help but stumble in to one.  Sometimes it's because <span class="math">\(n\)</span> is small and so it doesn't really matter if the algorithm is efficient.  And sometimes careful attention to the design of the algorithm can help keep the solver from getting side-tracked.  We'll talk more about these issues later.</p>
<h2 id="notes">Notes</h2>
<div class="footnotes">
<hr />
<ol>
<li id="fn:1">
<p>I'm waiving my hands here: it's not technically fixed.  Each iteration calls <code>done</code> once and either <code>right</code> or <code>down</code> once.  These all have <code>if</code>s and/or <code>||</code>s.  Those take a variable amount of time to execution, but they still have a maximum amount of time they can take.  So if we just pretend they always take that maximal amount, we can treat each call as a fixed cost.  That will never underestimate time and will never overestimate by more than a fixed factor.  The formal way of saying this is that they each take <span class="math">\(O(1)\)</span> time.<a href="#fnref:1" class="footnote-back-ref">&#8617;</a></p>
</li>
<li id="fn:2">
<p>We have to use <span class="math">\(O()\)</span> notation rather than just saying &ldquo;is proportional to&rdquo; because execution times are almost never <em>exactly</em> proportional to anything.  So the <span class="math">\(O(f(n))\)</span> notation says that for large enough values of <span class="math">\(n\)</span>, the thing being describe is never <em>larger</em> than some multiple of <span class="math">\(f(n)\)</span>.  What multiple?  We don't specify because we don't care.  We care that it's roughly growing with the same shape as <span class="math">\(f(n)\)</span>.  Why &ldquo;for large enough values&rdquo;?  Because <span class="math">\(f(n)\)</span> is usually some function that's zero when <span class="math">\(n\)</span> is zero and no algorithm runs in zero time &ndash; it at least has to execute a return instruction.  So we ignore the question of proportionality for small values of n.  The actual formal definition of big O is that when we say <span class="math">\(g(n) = O(f(n))\)</span> we mean that there are constants <span class="math">\(n_0\)</span> and <span class="math">\(k\)</span> such that <span class="math">\(g(n) \leq kf(n)\)</span> for all <span class="math">\(n &gt; n_0\)</span>.<a href="#fnref:2" class="footnote-back-ref">&#8617;</a></p>
</li>
<li id="fn:3">
<p>This is assuming the program does no other work besides making the choices.  If it's running some expensive algorithm between consecutive choices, then it will be worse.  Again, this is the best-case scenario.<a href="#fnref:3" class="footnote-back-ref">&#8617;</a></p>
</li>
<li id="fn:4">
<p>Again, this is only accounted for the time spent making choices.  It may be worse if we're doing a lot between the choices.  The details don't matter for us.  What matters is that simulating clairvoyance can add an exponentially large penalty to execution time.<a href="#fnref:4" class="footnote-back-ref">&#8617;</a></p>
</li>
<li id="fn:5">
<p><a href="https://en.wikipedia.org/wiki/Computational_complexity_theory">Complexity theory</a> places a lot of attention the distinction between problems that can be solved in <em>polynomial time</em>, that is <span class="math">\(O(n^k)\)</span> time for some <span class="math">\(k\)</span>, and exponential time, that is <span class="math">\(O(k^n)\)</span> for some <span class="math">\(k\)</span>.  The reason for this is that every polynomial scales better (more slowly) than every exponential.  In particular the ratio of any exponential to any polynomial goes to infinity as <span class="math">\(n\)</span> grows:</p>
<div class="math">
\[
\lim_{n\rightarrow\infty}\frac{(k_1)^n}{n^{k_2}}=\infty
\]</div>
<p>no matter what <span class="math">\(k_1, k_2\)</span> we choose.  In fact, it's common to treat polynomial-time as meaning &ldquo;tractable&rdquo;.  But as a practical matter, even polynomial algorithms are generally impractical unless <span class="math">\(k\)</span> or <span class="math">\(n\)</span> is small.<a href="#fnref:5" class="footnote-back-ref">&#8617;</a></p>
</li>
<li id="fn:6">
<p>The question of whether there's a way to simulate non-deterministic (clairvoyant) algorithms with a sub-exponential penalty is essentially the <a href="https://en.wikipedia.org/wiki/P_versus_NP_problem">P vs NP question</a>.  Thus far, no one has been able to prove it's impossible or that it's possible.  But it's generally believed that even if it's possible in principle, that in practice it would still be impractically slow.  You certainly wouldn't want to bet money on it being possible.<a href="#fnref:6" class="footnote-back-ref">&#8617;</a></p>
</li>
</ol>
</div>


<table style="border: none; width: 100%; table-layout: fixed; margin-top: 2rem;">
<tbody>
<tr style="border: none;">
				<td style="border: none; vertical-align: top; "> 
                    <b>Previous:</b> 
					<a title="Click or press &#8592;" class="simplelink" id="PreviousPage" href="NDScript_choice_paths.html">Choice paths
</a><br>
				</td>
				<td style="border: none; vertical-align: top; text-align: right;"> 
                    <b>Next:</b>  
					<a title="Click or press &#8594;" class="simplelink" id="NextPage" href="NDScript_execution.html">Execution
</a><br>
				</td>			
</tr>
</tbody>
</table>
			</div>
		</div>

		<div class="col-md-3">

<div class="container-fluid sidebar">
		<h3 style="text-align: right;">Incomplete draft:<br>do not cite!</h3>
				<p style="color: grey; padding-bottom: 0rem; margin-bottom: 0rem;">Section 1.1.1.1.3</p>
			<h5>Finding paths
</h5>
			<ol start="1">
					<li class="sidebar"><a class="backgroundlink" href="Verification.html" id="section_page_1"> Generation vs. verification
 </a> <br></li>
					<li class="sidebar"><a class="backgroundlink" href="NDScript_choice_paths.html" id="section_page_2"> Choice paths
 </a> <br></li>
					<li class="sidebar"><a class="simplelink" href="Execution_time.html" id="section_page_3"> <b> Execution time
 </b> </a> <br></li>
			</ol>
	<script>
		document.addEventListener('keyup', function(e) {
			if (e.key >= '1' && e.key <= '9') document.getElementById('section_page_'+e.key).click()
		}, false);
	</script>
	</p>
	<br>
	<h5>Navigation</h5>
	<p style="text-align: left;">
	<table style="border: none;">
			<tr style="border: none;">
				<td style="border: none; vertical-align: top;"> <b>Next:</b> </td>
				<td style="border: none;"> 
					<a title="Click or press &#8594;" class="simplelink" id="NextPage" href="NDScript_execution.html">Execution
</a><br>
				</td>
			</tr>
			<script>
				document.addEventListener('keyup', function(e) {
					if (e.getModifierState("Meta") || e.getModifierState("Control")) return
					if (e.key == 'ArrowRight' || e.key == "Return")
					  document.getElementById('NextPage').click()
				}, false);
			</script>
			<tr style="border: none;">
				<td style="border: none; vertical-align: top;"> <b>Previous:</b> </td>
				<td style="border: none;"> 
					<a title="Click or press &#8592;" class="simplelink" id="PreviousPage" href="NDScript_choice_paths.html">Choice paths
</a><br>
				</td>
			</tr>
			<script>
				document.addEventListener('keyup', function(e) {
					if (e.getModifierState("Meta")) return
					if (e.key == 'ArrowLeft') 
						document.getElementById('PreviousPage').click()
				}, false);
			</script>
			<tr style="border: none;">
				<td style="border: none; vertical-align: top;"> <b>Up:</b> </td>
				<td style="border: none;"> 
					<a title="Click or press &#8593;" class="simplelink" id="UpPage" href="Pathfinding.html">Finding paths
</a><br>
				</td>
			</tr>
			<script>
				document.addEventListener('keyup', function(e) {
					if (e.getModifierState("Meta")) return
					if (e.key == 'ArrowUp') document.getElementById(e.getModifierState("Control")?'linkToIndex':'UpPage').click()
				}, false);
			</script>
			<tr style="border: none;">
				<td style="border: none; vertical-align: top;"><b>Next &sect;:</b></td>
				<td style="border: none;"> 
					<a title="Click or press Control-&#8594;" class="simplelink" id="NextSectionPage" href="NDScript_execution.html">Execution
</a><br>
				</td>
			</tr>
			<script>
				document.addEventListener('keyup', function(e) {
					if (e.getModifierState("Meta")) return
					if (e.key == 'ArrowRight'  && e.getModifierState("Control")) document.getElementById('NextSectionPage').click()
				}, false);
			</script>
	</table>
	</p>
	<div style="color: grey; padding-top: .5rem;">
		<a style="color: grey;" href="mailto:ian@northwestern.edu?subject=Comment on DPGD/Execution_time.html">Send feedback on this page</a>
	</div>
</div>

		</div>
	</div>
</div>



<div class="container-fluid footer">
	<div class="container">
		<div class="row">
			<div class="col-10 col-lg-8 footer-contents">
				<div class="text-muted">
					<h4><a class="simplelink" href="index.html">Declarative Programming for Game Designers</a></h4>

					Copyright &copy; 2025 Ian Horswill
				</div>
				<div class="text-muted">
					<a href="https://github.com/rzubek/mies">Made by Booker, based on Rob Zubek's Mies (Crown Theme)</a>
				</div>
			</div>
		</div>
	</div>
</div>

<script>
	document.querySelectorAll('.language-step').forEach(e => {e.title = 'Click here to try the code'; });
</script>

<!-- this is required for bootstrap -->

<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

</body>
</html>
