---
pagetitle: Primitive tasks
status: early-draft
---
Up to now, we've looked almost exclusively at tasks that are defined by methods.  However, we've seen a couple of exceptions, such as the `Write` and `Not` predicates, which aren't defined by methods.  They're callable by Step, but they're not they're not written in Step.[^1]   Rather, they are a core part of the Step system itself.  Most programming languages have something like these, and they get referred to as **primitives** or **built-ins**.

Some of these tasks bring up issues that we haven't had to grapple with before, so let's talk about them now.

## Determinism

Many primitives, like `Write` do their work without making choices; they're called **deterministic** because their behavior is completely *determined* by their inputs.

Primitives that make choices are called **nondeterministic**.  Many of them are like 

 primitives --- sometimes make choices from such large sets of options that it's impractical for them to consider all possible choices.  For example, `RandomFloat`, which chooses a random number, are making a choice from such a large space of possibilities that it's impractical for them to try.[^2]

## Argument instantiation

A related issue is that some predicates, only work if particular parameters are either values, or variables that already have values.  Others might require particular parameters to be variables without values.  For example, the `Tuple` predicate is true (succeeds) if its parameter is a tuple, and false (fails) if it isn't.  However, if its parameter is a variable with no value, it generates an error.  You could imagine it binding the variable to some tuple to forcibly *make* it a tuple, but then again, there's an infinite number of possible tuples, and because of the way languages like this work internally, that isn't practical to do.

We'll now talk about a number of built-in tasks you might find useful.

## Endnotes

[^1]: Step itself is written in the C# language, so primitives are also written in C#.

[^2]: This is technically a lie.  Numbers in computers are represented using a finite number of bits and there are only a finite number of numbers you can represent using a finite number of bits.  However, `RandomFloat` is choosing from over four billion possible bit patterns, so drawing that in a choice diagram is not practical.