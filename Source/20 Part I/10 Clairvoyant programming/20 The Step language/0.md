---
pagetitle: "Step: a maximalist clairvoyant language"
shorttitle: Step
status: alpha
---
[Step](https://github.com/ianhorswill/Step) is a declarative programming language that's relatively easy to learn.  If you're familiar with [Prolog](https://en.wikipedia.org/wiki/prolog), it's basically a generalization of Prolog[^step] with a gentler learning curve.  It was developed for interactive narrative but is general-purpose in the sense that you can write any algorithm in it you can write in other languages.  If Prolog is a language for the Chess Club, Step is a language for theater kids.

We'll begin with how to write Step programs that print things.  Programs that only print things are basically [grammars](grammars).  Grammars are frequently used in games to make names of things (characters, items, planets, etc.) and quests.  Later, we'll show an [example text generator](starflight_pcg) from the influential 80's game *Starflight*  (Binary Systems, 1986), which was cited as an influence on both *Mass Effect* and *Dwarf Fortress*.

After showing you how to write simple grammars, we'll show you how to write [parameterized grammars](parameterized_grammars) that can intelligently print descriptions of things based on their characteristics.

Next, we'll show you how the same techniques used to write parameterized grammars can be used to write simple databases, and more importantly, query languages for those databases.  This is known as [logic programming](logic_programming) because those same techniques can be used (again) to let the computer perform an approximation to logical reasoning.

Standard logic programming makes it cumbersome to represent things that change over time.[^time_and_change]
Having looked at the basics of logic programming, we'll then look at how Step works with variables and other things whose [state](state_in_step) can change over time during the program.  This lets you more naturally write programs like planners or games that have world state.

Next, we'll discuss how to [structure information](structured_data) using lists, tuples, and "feature structures"[^feature_structures].  If you've seen [JSON](wiki:JSON), Step data structures are a lot like JSON objects that support a special kind of pattern matching.

The rest of the Step discussion is more technical.  [Primitive tasks](primitive_tasks) provides more information on the built-in operations in the language.  [Higher-order tasks](higher-order_tasks) discusses how Step code can be parameterized by other bits of Step code.  If you've programmed before, then you've seen things like this in the forms of statements like `while` and `if`: they take code (the stuff in `{ ... }`) as their arguments and they decide which of those things to run when.  Step has a much more general version of this that lets you write your own higher-order operations.

Finally, we'll talk about [reflection](reflection), which is the ability to write programs with a limited ability to reason about themselves.  This is useful for writing debugging tools, planners, and other kinds of programs.


## Notes

[^step]: Step is a generalization of [Prolog](wiki:Prolog)-style logic programming, [SHOP](https://www.cs.umd.edu/~nau/projects/shop/)-style HTN planners, and [definite-clause grammars](wiki:Definite_clause_grammar).  All use the same basic control structure, so they're easy to unify.  And all have been used in commercial games.

[^time_and_change]: Esoteric: historically, logic programming has tried to model the semantics of [formal logic](logic), whose variables behave like variables in math: they only have one value, and you can't update it by saying `x = x+1`.  Step includes both logic-like variables and variables like those of traditional programming languages.

[^feature_structures]: For programmers: feature structures are basically a kind of dictionary structure: mappings from string keys to arbitrary values.