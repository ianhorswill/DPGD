---
pagetitle: Simple logic programs
---
In the previous chapter, we discussed how a method such as:
```step
Weapon: [PreBuff] [WeaponType] [PostBuff]
```
can be though of as a **grammar rule** describing kinds of phrases:

> A weapon description is a pre-buff followed by a type followed by a post-buff

This chapter explores how other kinds of methods can be thought of as **logical rules** describing possible inferences.  This introduces three big ideas:

* **Predicates**: tasks that answer questions rather than printing things
* **Soft failure**: methods can fail.  Failure isn't an error, it just means Step tries another method.
* **Relaxed variables**: variables begin life without specific values and acquire values as your use them.

Together, they give us our first real example of clairvoyant (nondeterministic) programming: each call to each task involves choosing a method.  Some, or even most, of those methods might fail.  But the system behaves *as if* it always chooses correctly.

We'll see that this allows a programming style in which methods can be thought of as statements of fact. And the execution of certain tasks can naturally be thought of as answering questions about those facts.

## Preview

Here's a quick example to give you a sense of where we're headed.  By the end of the chapter, you'll understand how this stuff works, but for the moment, we'll wave our hands.  We're going to start by writing some methods for some Step tasks that don't print anything.  Don't worry about the `[predicate]` annotation[^1] or the fact that the methods end with periods rather than colons:
```Step
# Try: [Dog lassie]
[predicate]
Dog benji.
Dog lassie.

[predicate]
Cat morris.
Cat garfield.
```
If you aren't familiar with US pop culture from the 1970s, Benji and Lassie were famous dogs from movies, Morris was a cat from cat-food commercials, and Garfield is a famous cartoon cat.  So these methods form a little **database** of cats and dogs.

### Calls as queries

When we run `[Dog lassie]`, it works even though it doesn't print anything.  We say the call **succeeds**.  In detail, it:

* Tries to match `Dog lassie` to the first method `Dog benji`, but it can't because `benji` and `lassie` are different.  So that **method fails**.
* Then moves on to the second method, `Dog lassie`, which is a perfect match for the call.
* Then runs the method, but the method doesn't do anything. It just finishes.  We're done.

Now what happens if we run `[Dog garfield]`? 
```Step
# Try: [Dog garfield]
[predicate]
Dog benji.
Dog lassie.

[predicate]
Cat morris.
Cat garfield.
```
Neither method matches, so both methods fail.  That means the entire **call fails**.[^1]

So `Dog` executes successfully -- it **succeeds** -- if you call it with a parameter it knows to be a dog.  It **fails** if you call it with a something else.  So we can test the doghood of something by calling `Dog` with the something as a parameter.

Now what happens if we run `[Dog ?x]`?
```Step
# Try: [Dog ?]
[predicate]
Dog benji.
Dog lassie.

[predicate]
Cat morris.
Cat garfield.
```

You've only seen variables appear inside of methods.  But Step's command line lets you specify variables as parameters.  So what does running `[Dog ?x]` do?

* It tries to match `Dog ?x` against the first method, `Dog benji`.  That succeeds, setting `?x`=`benji`
* It runs the method, but the method doesn't print anything. It just finishes.
* The command line prints out `?x=benji`

So this query is like asking "who is a dog?", or equivalently, "give me the name of a dog."

### Methods as inference rules

Now suppse we add another task that doesn't print anything:
```step
[predicate]
Animal ?x: [Dog ?x]
Animal ?x: [Cat ?x]
```

When we run `[Animal lassie]`, it succeeds:
```Step
# Try: [Animal lassie]
[predicate]
Animal ?x: [Dog ?x]
Animal ?x: [Cat ?x]

[predicate]
Dog benji.
Dog lassie.

[predicate]
Cat morris.
Cat garfield.  
```
In detail, it:

* Tries to match the first method, i.e. matches `Animal lassie` to `Animal ?x`.  That works when `?x`=`lassie`.
* Then it runs `[Dog ?x]` which in this case means `[Dog lassie]`, since we know `?x` is `lassie`.
* That just recapitulates the example above, so it succeeds.
* So the method for `Animal` succeeds, and the call succeeds, even though nobody printed anything.

If we run `[Animal garfield]`, that succeeds too:
```Step
# Try: [Animal garfield]
[predicate]
Animal ?x: [Dog ?x]
Animal ?x: [Cat ?x]

[predicate]
Dog benji.
Dog lassie.

[predicate]
Cat morris.
Cat garfield.  
```
But it's a little more complicated:

* It tries to match the first method, i.e. matches `Animal garfield` to `Animal ?x`.  That works when `?x`=`garfield`.
* Then it runs `[Dog ?x]` which in this case means `[Dog garfield]`, since we know `?x` is `garfield`.
* We already saw that that call fails, so the `Animal`'s first method fails.
* So it tries the second method for `Animal`.  It matches too, but this time, we run `[Cat garfield]` rather than `[Dog garfield]`
* That succeeds, so the `Animal` method succeeds, and so the original call succeeds, again even though nobody printed anything.

On the other hand, if we run `[Animal coffee]`, that call *fails*:
```Step
# Try: [Animal coffee]
[predicate]
Animal ?x: [Dog ?x]
Animal ?x: [Cat ?x]

[predicate]
Dog benji.
Dog lassie.

[predicate]
Cat morris.
Cat garfield.  
```
When it runs this,

* The first method matches, but tries to run `[Dog coffee]`, which fails
* The second method matches, but tries to run `[Cat coffee]`, which also fails
* Both methods having failed, the call fails.

So, again `Animal` behaves like a test for animalhood: it succeeds when its argument is an animal.  It fails when the argument isn't an animal given the information available to the computer.  Once again, if we call `[Animal ?x]`, it will report back to us a value for `?x` that is an animal.  If we added `[randomly]` to all our tasks, then it would randomly chose the animal:
```Step
# Try: [Animal ?]
[predicate] [randomly]
Animal ?x: [Dog ?x]
Animal ?x: [Cat ?x]

[predicate] [randomly]
Dog benji.
Dog lassie.

[predicate] [randomly]
Cat morris.
Cat garfield.  
```

Although the computer is really just matching calls to methods, we as humans can interpret the method:
```step
Animal ?x: [Dog ?x]
```
as a rule saying:

> If $$x$$ is a dog, then it's an animal

Or equivalently:

> All dogs are animals

And similarly, the method:
```step
Animal ?x: [Cat ?x]
```
can be interpreted as:

> All cats are animals.

## Endnotes

[^1]: As well talk about [shortly](predicates), the `[predicate]` annotation simply tells Step not to consider failed calls to that task to be an error.