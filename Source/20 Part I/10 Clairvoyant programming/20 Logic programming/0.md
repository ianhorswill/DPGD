---
pagetitle: Simple logic programs
---
In the previous chapter, we discussed how a method such as:
```step
Weapon: [PreBuff] [WeaponType] [PostBuff]
```
can be though of as a **grammar rule** describing kinds of phrases:

> A weapon description is a pre-buff followed by a type followed by a post-buff

This chapter explores how other kinds of methods can be thought of as **logical rules** describing possible inferences.  This introduces three big ideas:

* **Predicates**: tasks that answer questions rather than printing things
* **Soft failure**: methods can fail.  Failure isn't an error, it just means Step tries another method.
* **Relaxed variables**: variables begin life without specific values and acquire values as your use them.

Together, they give us our first real example of clairvoyant (nondeterministic) programming: each call to each task involves choosing a method.  Some, or even most, of those methods might fail.  But the system behaves *as if* it always chooses correctly.

We'll see that this allows a programming style in which methods can be thought of as statements of fact. And the execution of certain tasks can naturally be thought of as answering questions about those facts.

## Preview

Here's a quick example to give you a sense of where we're headed.  By the end of the chapter, you'll understand how this stuff works, but for the moment, we'll wave our hands.  We're going to start by writing some methods for some Step tasks that don't print anything.  Don't worry about the `[predicate]` annotation[^1] or the fact that the methods end with periods rather than colons:
```Step
# Try: [Dog lassie]
[predicate]
Dog benji.
Dog lassie.

[predicate]
Cat morris.
Cat garfield.
```
If you aren't familiar with US pop culture from the 1970s, Benji and Lassie were famous dogs from movies, Morris was a cat from cat-food commercials, and Garfield is a famous cartoon cat.  So these methods form a little **database** of cats and dogs.

### Calls as queries

When we run `[Dog lassie]`, it works even though it doesn't print anything.  We say the call **succeeds**.  It goes like this:

* It can't match `Dog lassie` to the first method `Dog benji`, because `benji` and `lassie` are different; that **method fails**.
* However, `Dog lassie` is a perfect match for the call.
* It runs that method, but the method doesn't do anything. It just finishes.  We're done.

Now what happens if we run `[Dog garfield]`? 
```Step
# Try: [Dog garfield]
[predicate]
Dog benji.
Dog lassie.

[predicate]
Cat morris.
Cat garfield.
```
Neither method matches, so both methods fail.  That means the entire **call fails**.[^1]

So `Dog` executes successfully -- it **succeeds** -- if you call it with a parameter it knows to be a dog.  It **fails** if you call it with a something else.  So we can test the doghood of something by calling `Dog` with the something as a parameter.

Now what happens if we run `[Dog ?x]`?
```Step
# Try: [Dog ?]
[predicate]
Dog benji.
Dog lassie.

[predicate]
Cat morris.
Cat garfield.
```

You've only seen variables appear inside of methods.  But Step's command line lets you specify variables as parameters.  So what does running `[Dog ?x]` do?

* `Dog ?x` matches the first method, `Dog benji`, provided `?x`=`benji`
* So it runs the method.  Again, the method doesn't print anything. It just finishes.
* The command line reports back that `?x=benji`

So this query is like asking "who is a dog?", or equivalently, "give me the name of a dog," and it replies `benji`.

### Methods as inference rules

Now suppose we add another task that doesn't print anything:
```step
[predicate]
Animal ?x: [Dog ?x]
Animal ?x: [Cat ?x]
```

When we run `[Animal lassie]`, it succeeds:
```Step
# Try: [Animal lassie]
[predicate]
Animal ?x: [Dog ?x]
Animal ?x: [Cat ?x]

[predicate]
Dog benji.
Dog lassie.

[predicate]
Cat morris.
Cat garfield.  
```
In detail, it:

* Both methods for `Animal` match if we set `?x`=`lassie`.  It needs to guess which one to use.  Let's say it guesses the first one.
* That method calls `[Dog ?x]` which in this case means `[Dog lassie]`, since we know `?x` is `lassie`.
* That just recapitulates the example above, so it succeeds.
* So the method for `Animal` succeeds, and the call succeeds, even though nobody printed anything.

If we run `[Animal garfield]`, that succeeds too:
```Step
# Try: [Animal garfield]
[predicate]
Animal ?x: [Dog ?x]
Animal ?x: [Cat ?x]

[predicate]
Dog benji.
Dog lassie.

[predicate]
Cat morris.
Cat garfield.  
```
But it's a little more complicated:

* Both `Animal` methods matches if `?x`=`garfield`.  Again it needs to guess the right one.
* If it guesses the first method, that would fail because that method runs `[Dog ?x]` and `?x` is `garfield`, which isn't a dog.
* So it doesn't guess the first method, it guesses the second method.  That method runs `[Cat garfield]` rather than `[Dog garfield]`
* `[Cat garfield]` succeeds, so the `Animal` method succeeds, and so the original call succeeds, again even though nobody printed anything.

On the other hand, if we run `[Animal coffee]`, that call *fails*:
```Step
# Try: [Animal coffee]
[predicate]
Animal ?x: [Dog ?x]
Animal ?x: [Cat ?x]

[predicate]
Dog benji.
Dog lassie.

[predicate]
Cat morris.
Cat garfield.  
```
When it runs this, both `Animal` methods match, but neither `[Dog coffee]` nor `[Cat coffee]` could succeed, so there's no valid method to guess.  So the call `[Animal coffee]` fails. 

So, again `Animal` behaves like a test for animalhood: it succeeds when its argument is an animal.  It fails when the argument isn't an animal given the information available to the computer.  Once again, if we call `[Animal ?x]`, it will report back to us a value for `?x` that is an animal.  If we added `[randomly]` to all our tasks, then it would randomly choose the animal:
```Step
# Try: [Animal ?]
[predicate] [randomly]
Animal ?x: [Dog ?x]
Animal ?x: [Cat ?x]

[predicate] [randomly]
Dog benji.
Dog lassie.

[predicate] [randomly]
Cat morris.
Cat garfield.  
```

Although the computer is really just matching calls to methods, we as humans can interpret the method:
```step
Animal ?x: [Dog ?x]
```
as a rule saying:

> If $$x$$ is a dog, then it's an animal

Or equivalently:

> All dogs are animals

And similarly, the method:
```step
Animal ?x: [Cat ?x]
```
can be interpreted as:

> All cats are animals.

## Endnotes

[^1]: As well talk about [shortly](predicates), the `[predicate]` annotation simply tells Step not to consider failed calls to that task to be an error.